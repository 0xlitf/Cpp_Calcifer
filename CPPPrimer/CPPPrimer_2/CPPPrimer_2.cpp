// CPPPrimer_2.cpp : 定义控制台应用程序的入口点。
//变量和基本类型

#include "stdafx.h"
#include <iostream>
int m_initialized;
int _tmain(int argc, _TCHAR* argv[])
{
	unsigned u = 10;
	int i = -42;
//	int m_uninitialized;//报错
//	std::cout << m_initialized << std::endl
//			<< m_uninitialized << std::endl;



	using INT = int;
	INT i_typedef = 1;
	std::cout << "i_typedef=" << i_typedef << std::endl;\



	double price = 5, discount = price * 5;//同一条定义语句中，可以用先定义的变量值去初始化后定义的其他变量。

	int m_test_1 = 0;		//初始化的不同形式
	int m_test_2 = { 0 };
	int m_test_3{ 0 };
	int m_test_4(0);

	int m_reference_test = 1;
	int &m_reference = m_reference_test;
//	int &m_reference_2;//报错，引用必须被初始化。

	/*声明使得名字为程序所知，一个文件如果想使用别处定义的名字则必须包含对那个名字的声明。
		定义负责创建与名字关联的实体。
		如果想声明一个变量而非定义它，就在变量名前添加关键字extern而且不要显示的初始化变量。*/
	extern int m_extern;//声明而非定义
	int m_define = 1;		//声明并定义


	std::cout << i + i << std::endl;
	std::cout << i + u << std::endl;//既有无符号数又有int值，int会转换成无符号数。
//	for (unsigned u_in_for = 10; u_in_for >= 0; u_in_for--)
//		std::cout << u_in_for << std::endl;//循环不能停止。
	std::cin.get();
	return 0;
}
/*
CPPPrimer_2.1 基本内置类型
	2.11 算数类型
		C++定义了一套包括算术类型（arithmetic type）和空类型（void）在内的基本数据类型。
		其中算术类型包含了字符、整型数、布尔值和浮点数。空类型不对应具体的值。
		算术类型分为两类：整型和浮点型。
		算术类型的尺寸（也就是该类型所占的比特数）在不同机器上有所差别。
		计算机以2的整数次幂个比特座位块来处理内存，可寻址的最小内存块成为“字节（byte）”，存储的基本单元称为“字（word）”，
		它通常由几个字节组成。
		大多数计算机将内存中的每个字节与一个数字（被称为“地址（address）”）关联起来。
		除去布尔型和扩展的字符型之外，其他整型可以划分为带符号的（signed）和无符号的（unsigned）两种。
		带符号的可以表示正数、负数和0，无符号的可以表示大于等于0的值。
		类型int、short、long和long long都是带符号的，通过在这些类型名前添加unsigned就可以得到无符号类型，
		unsigned int可以缩写为unsigned。
		字符型被分为了三种：char、signed char和unsigned char。
		char和signed char并不一样，尽管字符型有三种，但是字符的表现形式却只有两种：带符号的和无符号的。
		类型char实际上会表现为上述两种形式中的一种，具体是哪种由编译器决定。

		下边这句话我不造是搞鸡毛：
		C++标准并没有规定带符号类型应如何表示，但是约定了在表示范围内正值和负值的量应该平衡。
		因此，8比特的signed char理论上应该可以表示-127至127区间内的值，
		大多数现代计算机将实际的表示范围定为-128至127。
	2.12 类型转换
		对象的类型定义了对象能包含的数据和能参与的运算，其中一种运算被大多数类型支持，就是将对象从一种给定的类型
		转换（convert）为另一种相关类型。
		当程序的某处我们使用了一种类型而其实对象应该取另一种类型时，程序会自动进行类型转换。
		类型所能表示的值的范围决定了转换的过程：
		非布尔类型的算术值赋给布尔类型时，初始值为0则结果为false，否则结果为true。
		布尔值赋给非布尔类型时，初始值为false则结果为0，初始值为true则结果为1。
		浮点数赋给整数类型时，进行了近似处理。结果值将仅保留浮点数中小数点之前的部分。
		整数值赋给浮点类型时，小数部分记为0.如果该整数所占的空间超过了浮点类型的容量，精度可能有损失。
		赋给无符号类型一个超出它表示范围的值时，结果是初始值对无符号类型表示数值总数取模后的余数。
		-1赋给8比特大小的unsigned char所得的结果是255。
		切勿混用带符号类型和无符号类型。
	2.13 字面值常量
		一个形如42的值被称作字面值常量。
		整型和浮点型字面值；
		字符和字符串字面值；
		转义序列；
		指定字面值的类型；
		布尔字面值和指针字面值：
			true和false是布尔类型的字面值，
			nullptr是指针的字面值。
CPPPrimer_2.2 变量
		变量提供一个具名的、可供程序操作的存储空间。C++中每个变量都有其数据类型，
		数据类型决定着变量所占内存空间的大小和布局方式、该空间能存储的值的范围，
		以及变量能参与的运算。
	2.21 变量定义
		变量定义的基本形式是：首先是类型说明符（type specifier），随后紧跟由一个或多个变量名组成的列表，
		其中变量名以逗号分隔，最后以分号结束。列表中每个变量名的类型都由类型说明符指定，
		定义时还可以为一个或多个变量赋初值。

		初始化不是赋值，初始化的含义是创建变量时赋予其一个初始值，而赋值的含义是把对象的当前值擦除，而以一个新值来代替。

		如果定义变量时没有指定初值，则变量被默认初始化，此时变量被赋予了“默认值”。
		默认值到底是由什么变量类型决定，同时定义变量的位置也会对此有影响。
		如果是内置类型的变量未被显式初始化，它的值是由定义决定。
		任何定义在函数体之外的变量被初始化为0。一种例外情况是，定义在函数体内部的内置类型变量将不被初始化。
		一个未被初始化的内置类型的变量的值是未定义的，如果试图拷贝或以其他形式访问此类值将引发错误。
		每个类各自决定其初始化对象的方式。而且，是否允许不经初始化就定义对象也由类自己决定。
		如果类允许这种行为，它将决定对象的初始值到底是什么。

	2.22 变量声明和定义的关系
		声明使得名字为程序所知，一个文件如果想使用别处定义的名字则必须包含对那个名字的声明。
		定义负责创建与名字关联的实体。
		如果想声明一个变量而非定义它，就在变量名前添加关键字extern而且不要显示的初始化变量。
		任何包含了显式初始化的声明即成为定义。
		在函数体内部，如果试图初始化一个由extern关键字标记的变量，将引发错误。
		变量能且只能被定义一次，但是可以被多次声明。
	2.23 标识符
	2.24 名字的作用域
		名字main定义在所有花括号之外，它和其他大多数定义在函数体之外的名字一样拥有全局作用域（global scope）。
		块作用域（block scope）。
		作用域能彼此包含，被包含的作用域成为内层作用域（inner scope），
		包含着别的作用域的作用域称为外层作用域（outer scope）。
		可以用（::）显示访问全局变量。
		
CPPPrimer_2.3 复合类型
		复合类型（compound type）是指基于其他类型定义的类型：引用和指针。
		一条声明语句由一个基本数据类型（base type）和紧随其后的一个声明符（declarator）列表组成，
		每个声明符命名了一个变量并制定该变量为与基本数据类型有关的某种类型。
		2.31 引用
		“引用（reference）”一般指左值引用，为对象起了另外一个名字，引用类型引用（refers to）另外一种类型，
		通过将声明符写成&d的形式来定义引用类型，其中d是声明的变量名。

		引用必须被初始化。
		一般初始化变量时，初始值会被拷贝到新建的对象中。然而定义引用时，程序把引用和它的初始值绑定（bind）在一起，
		而不是将初始值拷贝给引用。一旦初始化完成，引用将和它的初始值对象一直绑定在一起。
		因为无法令引用重新绑定到另外一个对象，因此引用必须被初始化。
		引用即别名。
		引用并非对象，相反的，它只是一个为已经存在的对象所起的另外一个名字。
		定义了一个引用后，对其进行的所有操作都是在与之绑定的对象上进行的。
		引用不是一个对象，所以不能定义引用的引用。
		允许在一条语句中定义多个引用，其中每个引用标识符都必须以符号（&）开头。
		int &a = i,&b = j;
		引用只能绑定在对象上，而不能与字面值或某个表达式的计算结果绑定在一起。

		2.32 指针
		指针（pointer）是“指向（point to）”另外一种类型的复合类型。与引用类此，指针也实现了对其他对象的间接访问。
		指针和引用相比有许多不同点：
		1、指针本身就是一个对象，允许对指针赋值和拷贝，而且在指针的生命周期内它可以先后指向几个不同的对象。
		2、指针无需再定义时赋初值。
		和其他内置类型一样，在块作用域内定义的指针如果没有被初始化，也将有用一个不确定的值。

		指针存放某个对象的地址，要想获取该地址，需要使用取地址符（操作符&）：
		int ival =42;
		int *p = &ival;
		因为引用不是对象，没有实际地址，所以不能定义指向引用的指针。

		double dval;
		double *pd = &dval;//正确：初始值是指向double对象的地址
		double *pd2 = pd;//正确：初始值是指向double对象的指针

		int *pi = pd;//错误：指针pi的类型和pd的类型不匹配
		pi = &dval;//错误：试图把double型对象的地址赋给int型指针
		因为在声明语句中指针的类型实际上被用于指定它所指向对象的类型，所以二者必须匹配。
		如果指针指向了一个其他类型的对象，则该对象的操作将发生错误。

		指针的值（即地址）应属下列4种状态之一：
		1、指向一个对象
		2、指向紧邻对象所占空间的下一个位置
		3、空指针，意味着指针没有指向任何对象
		4、无效指针，也就是上述情况之外的其他值

		利用指针访问对象
		如果指针指向了一个对象，则允许使用解引用符（操作符*）来访问该对象：
		int ival = 42；
		int *p = &ival;
		cout << *p;//由符号*得到指针p所指的对象，输出42

		空指针
		空指针（null pointer）不指向任何对象，在试图使用一个指针之前代码可以首先检查它是否为空。
		生成空指针的方法：
		int *p1 = nullptr;//等价于int *p1 = 0；
		int *p2 = 0;		//直接将p2初始化为字面常量0
		//需要首先#include cstdlib
		int *p3 =NULL;//等价于int *p3 = 0；
		NULL是一个预处理变量（preprocessor variable），它的值就是0。

		把int变量直接赋给指针是错误的操作，即使int变量的值恰好等于0也不行。
		int zero = 0；
		pi = zero；//错误，不能把int变量直接赋给指针
		对于两个类型相同的合法指针可以用（==）和（！=）来比较，结果是布尔类型。
		指针存放的地址值相同有三种可能：他们都为空，都指向同一个对象，或者都指向了同一个对象的下一个地址。
		需要注意，一个指针指向某对象，同时另一个指针指向另外对象的下一地址，此时也有可能出现这两个指针值相同的情况，即指针相等。
		
		void*指针是一种特殊的指针类型，可用于存放任意对象的地址。
		利用void*指针能做的事比较有限：拿它和别的指针比较，作为函数的输入和输出，或者赋给另外一个void*指针。
		不能直接操作viod*指向的对象，因为我们不知道这个对象到底是什么类型。

		2.33 理解复合类型的声明
		同一条定义语句中，虽然基本数据类型只有一个，但是声明符的形式却可以不同。
		也就是说，一条定义语句可能定义出不同类型的变量：
		int i = 1024,*p = &i, &r = i;

		通过*的个数可以区分指针的级别：
		int ival = 1024;
		int *pi = &ival;
		int **ppi = &pi;

		指向指针的引用
		引用本身不是一个对象，因此不能定义指向引用的指针。
		但指针是对象，所以存在对指针的引用：
		int i = 42;
		int *p;//p是一个int型指针
		int *&r = p;//r是一个对指针p的引用

		r = &i;//r引用了一个指针，因此给r赋值&i就是令p指向i
		*r = 0;//解引用r得到i，也就是p指向的对象，将i的值改为0
		从右向左阅读r的定义，离变量名最近的符号对变量的类型有最直接的影响，因此r是一个引用。
		声明符的其余部分用以确定r引用的类型是什么，此例中的符号*说明r引用的是一个指针。
		最后，声明的基本数据类型部分支出r引用的是一个int指针。

CPPPrimer_2.4 const限定符
		主要的限制是只能在const类型的对象上执行不改变其内容的操作。
		默认情况下，const对象仅在文件内有效。
		某些时候又这样一种const变量，它的初始值不是一个常量表达式，但又缺失有必要在文件间共享。
		这种情况下，我们不希望编译器为每个文件分别生成独立的变量，
		相反，我们想让这类const对象像其他（非常量）对象一样工作，
		也就是说，志在一个文件中定义const，而在其他多个文件中声明并使用它。
		解决的办法是，对于const变量不管是声明还是定义都添加extern关键字。、
		2.41 const的引用
		可以把引用绑定到const对象上，我们称之为对常量的引用（reference to const）
		引用的类型必须与其所引用的对象的类型一致，但是有两个例外。
		第一种例外情况就是再初始化常量引用时允许用任意表达式作为初始值，只要该表达式的结果能转换成引用的类型即可。
		int i = 42;
		const int &r1 = i;//允许将const int&绑定到一个普通int对象上
		const int &r2 = 42;//r1是一个常量引用
		const int &r3 = r1 * 2;//r3是一个常量引用
		int &r4 = r1 * 2;//错误：r4是一个普通的非常量引用

		对const的引用可能引用一个并非const的对象

		2.42 指针和const
		与引用一样，也可以令指针指向常量或非常量。类似于常量引用，指向常量的指针（pointer to const）不能用于改变其
		所指对象的值。
		要想存放常量对象的地址，只能使用指向常量的在指针。
		const double pi = 3.14;//pi是一个常量，它的值不能改变
		double *ptr = &pi;//错误，ptr是一个普通指针
		cpmst double *cptr = &pi;//正确，cptr可以指向一个双精度常量
		*cptr = 42;//错误，不能给*cptr赋值

		顶层const表示指针本身是个常量，底层const表示指针所指的对象是一个常量。

		2.44 constexpr和常量表达式
		常量表达式是指值不会改变，并且在编译过程就能得到计算结果的表达式。
		C++11新标准规定，允许将变量声明为constexpr类型以便由编译器来验证变量的值是否是一个常量表达式。
		声明为constexpr的变量一定是一个常量，而且必须用常量表达式初始化。

CPPPrimer_2.5 处理类型
		2.51 类型别名
		类型别名是一个名字，是某种类型的同义词：
		第一种用于定义类型别名的方法：typedef
		typedef double wages;//wages是double的同义词
		typedef wages base,*p;//base是double的同义词，p是double*的同义词
		第二种C++11新标准规定的方法，使用别名声明（alias declaration）来定义类型的别名：
		using SI = Sales_item；//SI是Sales_item的同义词
		把等号左侧的名字规定称等号右侧类型的别名。
		2.52 auto类型说明符
		auto一般会忽略掉顶层const，而底层const则会保留下来。
		2.53 decltype类型指示符
		decltype选择并返回操作数的数据类型，此过程中，编译器分析表达式并得到它的类型，却不实际计算表达式的值。

CPPPrimer_2.6 自定义数据结构
		struct和class定义类后要加分号
		确保头文件多次包含仍能安全工作的常用技术是预处理器（proprocessor），它由C++语言从C语言集成而来。
		预处理器是在编译之前执行的一段程序，可以部分的改变我们所写的程序。
		C++程序还会用到的一项预处理功能是头文件保护符（header guard），头文件保护符依赖于预处理变量。
		预处理变量有两种状态：已定义和未定义。
		#define指令把一个名字设定为预处理变量，
		另外两个指令则分别检查某个指定的预处理变量是否已经定义：
		#ifdef当且仅当变量已定义时为真，
		#ifndef当且仅当变量未定义时为真，一旦检查结果为真，则执行后续操作直至遇到#endif指令为止。
		#ifndef XX_H
		#define XX_H
		...
		#endif

*/