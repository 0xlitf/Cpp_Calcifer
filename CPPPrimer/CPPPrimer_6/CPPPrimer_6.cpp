// CPPPrimer_6.cpp : 函数
// CPPPrimer_6 函数

#include "stdafx.h"
#include <iostream>
using namespace std;
									//argc表示数组中字符串的数量
int _tmain(int argc, _TCHAR* argv[])//argv是一个数组，它的元素指向C风格字符串的指针；
//也可以定义成int _tmain(int argc, _TCHAR* *argv)argv指向char*
//当实参传给main函数之后，argv的第一个元素指向程序的名字或者一个空字符串，
//接下来的元素依次传递命令行提供的实参，最后一个指针之后的元素之保证为0
{
	int m_val = 5;
	int factorial(int val);
	cout << factorial(5)<<endl;
	cin.get();
	return 0;
}

int factorial(int val)
{
	if (val > 1)
		return factorial(val - 1)*val;
	return 1;
}
/*
6.1 函数基础
	函数是一个命名了的代码块，通过调用函数执行相应的代码。
	可以重载函数，同一个名字可以对应几个不同的函数。



	一个典型的函数定义包括以下部分：返回类型（return type）、函数名字、又0个或多个形参（parameter）组成的列表以及函数体。
	其中形参以逗号隔开，形参的列表位于一对圆括号之内。
	函数执行的操作在语句块中说明，该语句块成为函数体。
	通过调用运算符（call operator）来执行函数，调用运算符的形式是一对圆括号，它作用于一个表达式，该表达式是函数或者指向函数的指针；
	圆括号之内是一个用逗号隔开的实参（argument）列表，我们用实参初始化函数的形参。
	调用表达式的类型就是函数的返回类型。

	函数的调用完成两项工作：一是用实参初始化函数对应的形参，二是将控制权转移给被调用函数。
	此时主调函数（calling function）的执行被暂时中断，被调函数（called function）开始执行。
	执行函数的第一步是（隐式的）定义并初始化它的形参。
	当遇到一条return语句时，函数结束执行过程。
	和函数调用一样，return语句也完成两项工作：一是返回return语句中的值（如果有的话），
	二是将控制权从被调函数转移回主调函数。
	函数的返回值用于初始化调用表达式的结果，之后继续完成调用所在的表达式的剩余部分。

	形参和实参：
		实参是形参的初始值。第一个实参初始化第一个形参，第二个实参初始化第二个形参，以此类推。
		尽管实参与形参存在对应关系，但是并没有规定实参的求值顺序。编译器能以任意可行的顺序对实参求值。

	函数的形参列表可以为空，但是不能省略。
	形参列表中的形参通常用逗号隔开，其中每个形参都是含有一个声明符的声明。即使两个形参的类型一样，也必须把两个类型都写出来：
	int f3(int v1,v2);//错误
	int f4(int v1,int v2);//正确
	任意两个形参都不能同名，而且函数最外层作用域中的局部变量也不能使用与函数形参一样的名字。

	对于普通局部变量对应的对象来说，当函数的控制路径经过变量定义语句时创建该对象，当到达定义所在的块末尾时销毁它。
	我们把只存在于块执行期间的对象成为自动对象（automatic object）。
	当块的执行结束后，块中创建的自动对象的值就变成了未定义的。
	形参是一种自动对象。
	函数开始时为形参申请存储空间，因为形参定义在函数体作用域之内，所以一旦函数终止，形参也就被销毁。
	我们用传递给函数的实参初始化形参对应的自动对象。
	对于局部变量对应的自动对象来说，则分为两种情况：
	如果变量定义本身含有初始值，就用这个初始值进行初始化；
	否则，如果变量定义本身不含初始值，执行默认初始化。

	局部静态变量
	某些时候，有必要令局部变量的生命周期贯穿函数调用及之后的时间，
	可以讲局部变量定义成static类型从而获得这样的对象。
	局部静态变量（local static object）在程序执行路径第一次经过对象定义语句时初始化，并且知道程序终止才被销毁，
	在此期间，即使对象所在的函数结束执行也不会对它有影响。

	6.12 函数声明
	和其他名字一样，函数的名字也必须在使用之前声明。
	类似于变量，函数只能定义一次，但可以声明多次。
	如果一个函数永远不会被调用，那么它可以只有声明，没有定义。
	函数的声明和函数的定义非常类似，唯一的区别是函数声明无需函数体，用一个分号替代即可。
	函数声明也称作函数原型（function prototype）。

6.2 参数传递
	每次调用函数式都会重新创建它的形参，并用传入的实参对形参进行初始化。
	形参初始化的吉利与变量初始化一样。
	和其他变量一样，形参的类型决定了形参和实参交互的方式。
	如果形参是引用类型，它将绑定到嘴硬的实参上，否则将实参的值拷贝后赋给形参。
	当形参是引用类型时，我们说它对应的实参被引用传递（passed by reference）或者函数被传引用调用（called by reference）。
	和其他引用一样，引用形参也是它绑定的对象的别名；也就是说，引用形参是它对应实参的别名。
	当实参的值被拷贝给形参时，形参和实参是两个相互独立的对象，我们就说这样的实参被值传递（passed by value）或者函数被传值调用（called by value）。
	传值参数
	当初始化一个非引用类型的变量时，初始值被拷贝给变量。
	指针形参
	指针的行为和其他非引用类型一样，当执行指针拷贝操作时，拷贝的是指针的值。
	拷贝之后是两个指针是不同的指针。

	6.22 传引用参数
	对于引用的操作实际上是作用在引用所引的对象上：
	int n = 0,i = 42;
	int &r = n;//r绑定了n（r是n的另一个名字）
	r = 42;//现在n的值是42
	r = i;//现在n的值和i相同
	i = r;//i的值和n相同

	引用形参的行为与之类似。通过使用引用形参，允许函数改变一个或多个实参的值。
	//该函数接受一个int对象的引用，然后将对象的值置为0
	void reset(int &i) //i是传给reset函数的对象的另一个名字
	{
		i = 0; //改变了i所引对象的值
	}
	和其他引用一样，引用形参绑定初始化它的对象，
	当调用这一版本的reset函数时，i绑定我们传给函数的int对象，此时改变i也就是改变i所引对象的值。
	
	使用引用避免拷贝：
	拷贝大的类类型对象或者容器对象比较低效，甚至有的类类型（包括IO类型在内）
	根本就不支持拷贝操作。当某种类型不支持拷贝操作时，函数只能通过引用形参访问该类型的对象。
	如果函数无需修改引用形参的值最好使用常量引用。

	使用引用形参返回额外信息：
	一个函数只能返回一个值，然而有时函数需要返回多个值，引用形参为我们一次返回多个结果提供了有效的途径。

	6.23 const形参和实参
	顶层const作用于对象本身。

	const int ci = 42;//不能改变ci，const是顶层的
	int i = ci;//正确，当拷贝ci时，忽略了它的顶层const
	int * const p = &i;//const是顶层的，不能给p赋值
	*p = 0;//正确：通过p改变对象的内容是允许的
	和其他初始化一样，当用实参初始化形参时会忽略掉顶层const。换句话说，形参的顶层const被忽略掉了。
	当形参有顶层const时，传给他常量对象或者非常量对象都是可以的。
	void fcn(const int i){}等价于void fcn(int i){}
	
	指针或引用形参与const
	形参的初始化方式和变量的初始化方式是一样的。

	数组形参
	数组的两个性质对我们定义和使用作用在数组上的函数有影响，这两个性质分别是：
	不允许拷贝数组以及使用数组时通常会将其转换成指针，
	因为不能拷贝数组，所以无法以值传递的方式使用数组参数。
	因为数组会被转换成指针，所以当我们为函数传递数组时，实际上传递的是指向数组首元素的指针。

	尽管不能以值传递的方式传递数组，但是可以把形参写成类似数组的形式：
	//尽管形式不同，但是这三个print函数是等价的
	//每一个函数都有一个const int*类型的形参
	void pring(const int*);
	void pring(const int*[]);//函数的意图是作用于一个数组
	void pring(const int*[10]);//这里的维度表示我们期望数组含有多少个元素，实际上不一定
	当编译器处理对print函数的调用时，只检查传入的 参数是否是const int*类型：
	int i = 0,j[2] = {0.1};
	pring(&i);//正确，&i的类型是int*
	pring(j);//正确，j转换成int*并指向j[0]

	使用标记指定数组长度
	...
	使用标准库规范
	管理数组实参的第二种技术是传递指向数组首元素和尾后元素的指针，这种方法受到标准库技术的启发：
	void pring(const int *beg,const int *end)
	{
		while (beg != end)
			cout << *beg++;
	}
	为了调用这个函数，需要传入两个指针：一个指向要输出的首元素，另一个指向尾元素的下一位置。
	int j[2] = {0,1};
	pring(begin(j),end(j));
	只要调用者能正确的计算指针所指的位置，代码就是安全的。

	数组形参和const
	我们关于三个pring函数都把数组形参定义成了指向const的指针，关于引用的讨论同样适用于指针。
	当函数不需要对数组元素执行写操作的时候，数组形参应该是指向const的指针。
	只有当函数缺失要改变元素值的时候才把形参定义成指向非常量的指针。

	数组引用形参
	C++语言允许将变量定义成数组的引用，基于同样的道理，形参也可以是数组的引用。
	此时，引用形参绑定到对应的数组上：
	void pring(int (&arr)[10])//&arr两端的括号不可少
	{
		for (auto elem : arr)
			cout << elem;
	}

	6.26 含有可变形参的函数
	看不懂


6.3 返回类型和return语句
	return语句由两种形式：
	return;
	return expression;

	6.31 无返回值的return语句只能用在返回类型是void的函数中。
	返回void的函数不要求非得有return语句，因为会隐式的执行return。
	通常void函数如果想在它的中间位置提前退出，可以使用return语句，类似于用break函数退出循环。
	6.32 有返回值的函数只要返回类型不是void，则该函数内的每条return语句必须返回一个值。
	return语句返回值的类型必须与函数的返回类型相同，或者能隐式的转换成函数的返回类型。

	值是如何被返回的：
	返回一个值的方式和初始化一个变量或形参的方式完全一样：返回的值用于初始化调用点的一个临时量，该临时量就是函数调用的结果。
	
	不要返回局部变量的引用或指针。

	返回类类型的函数和调用运算符
	...
	引用返回左值
	函数的返回类型决定函数调用是否是左值。
	调用一个返回引用的函数得到左值，其他返回类型得到右值。

	递归
	如果一个函数调用了它自身，不管这种调用是直接还是间接的，都成该函数为递归函数（recursive function）：
	int factorial(int val)
	{
		if(val > 1)
			return factorial(val - 1);
		return 1;
	}
	main函数不能调用它自身。

	6.33 返回数组指针
	因为数组不能被拷贝，所以函数不能返回数组，不过，函数可以返回数组的指针或引用。
	要想定义一个返回数组的指针或引用的函数比较烦琐，最直接的方法是使用类型别名：
	typedef int arrT[10];//arrT是一个类型别名，它表示的类型是含有10个整数的数组
	using arrT = int[10];
	arrT* func(int i);//func返回指向含有10个整数的数组的指针

	声明一个返回数组指针的函数
	要想在声明func时不适用类型别名，我们必须牢记被定义的名字后面数组的维度：
	int arr[10];//arr是一个含有10个整数的数组
	int *p1[10];//p1是一个含有10个指针的数组
	int (*p2)[10];//p2是一个指针，它指向一个含有10个整数的数组

	和这些声明一样，如果想定义一个返回数组指针的函数，则数组的维度必须跟在函数名字之后。
	然而，函数的形参列表也跟在函数名字后面且形参列表应该先于数组的维度。
	因此，返回数组指针的函数形式如下：
	Type (*function(parameter_list))[dimension]
	类似于其他数组的声明，Type表示元素的类型，dimension表示数组的大小。
	(*function(parameter_list))两端的括号必须存在，否则函数的返回类型将是指针的数组。
	int (*func(int i))[10];
	可以按照以下的顺序来逐层理解该声明的含义：
	func(int i)表示函数需要一个int类型的实参
	(*func(int i))表示可以解引用
	(*func(int i))[10]表示解引用func的调用将得到一个大小是10个数组
	int (*func(int i))[10]表示数组中的元素类型是int类型
	使用尾置返回类型，C++11规定一种简化上述func声明的方法，就是使用尾置返回类型。
	任何函数的定义都能使用尾置返回，但是这种形式对于返回类型比较复杂的函数最有效，比如返回类型是数组的指针
	或者数组的引用。
	尾置返回类型跟在形参列表之后并以一个->符号开头。
	为了表示函数真正的返回类型跟在形参列表之后，我们在本该出现返回类型的地方放置一个auto：
	//func接受一个int类型的实参，返回一个指针，该指针指向含有10个整数的数组
	auto func(int i) -> int(*)[10];
	使用decltype
	如果知道函数返回的指针将指向哪个数组，就可以使用decltype关键字声明返回类型。




6.4 函数重载
	main函数不能重载。
	如果同一作用域内的几个函数名字相同但形参列表不同，我们称之为重载（overload）函数。
	不允许两个函数出了返回类型外其他所有要素都相同。
	函数中形参名字可省略。形参名字仅仅起到帮助记忆的作用，有没有它并不影响形参列表的内容。

	重载和const形参
	顶层const不影响传入函数的对象，一个拥有顶层const的形参无法和另一个没有顶层const的形参区别开。
	int l(i);
	int l(const i);//重复声明。

	int l(i*);
	int l(i* const);//重复声明。

	6.41 重载与作用域
	重载对作用域的一般性质并没有声明改变：
	如果我们在内层作用域中声明名字，它将隐藏外层作用域中声明的同名实体。


6.5 特殊用途语言特性
	6.51 默认实参
	某些函数有这样一种形参，在函数的很多次调用中他们都被赋予了一个相同的值，
	辞职，我们把这个反复出现的值成为默认实参（default argument）。
	调用含有默认实参的函数时，可以包含该实参，也可以省略该实参。
	我们可以为一个或多个形参定义默认值，不过需要注意的是，一旦某个形参被赋予了默认值，它后面的所有形参都必须有默认值。

	使用默认实参调用函数
	如果想使用默认实参，只要在调用函数的时候省略该实参就可以了。
	默认实参声明
	对于函数的声明来说，通常的习惯是将其放在头文件中，并且一个函数只声明一次，但是多次声明同一个函数也是合法的。
	不过有一点，在给定的作用域中一个形参只能被赋予一次默认实参。
	换句话说，函数的后续声明只能为之前那些没用默认值的形参添加默认实参，而该形参右侧的所有形参必须都有默认值（看不懂）。

	6.52 内联函数和constexpr函数
	constexpr函数是指能用于常量表达式的函数。
	
	6.53 调试帮助
	assert预处理宏。
	所为预处理宏其实是一个预处理变量，assert宏使用一个表达式作为它的条件：
	assert（expr）；
	首先对expr求值，如果表达式为假（即0），assert输出信息并终止程序的执行。如果是真，则什么都不做。






6.6 函数匹配
	函数匹配的第一步是选定本次调用对应的重载函数集，集合中的函数成为候选函数（candidate function）。
	候选函数具备两个特征：
	一是与被调用的函数同名，二是其声明在调用点可见。
	第二步考察本次调用提供的实参，然后从候选函数中选出能被这组实参调用的函数，
	这些新选出的函数成为可行函数（viable function）。
	可行函数也有两个特征：一是其形参数量与本次调用提供的实参数量相等，
	二是每个实参的类型与对应的实参类型相同或者能转换成形参的类型。

	寻找最佳匹配（如果有的话）

	二义性
	...











6.7 函数指针
	函数指针指向的是函数而非对象。和其他指针一样，函数指针指向某种特定类型。
	函数的类型由它的返回类型和形参类型共同决定，与函数名无关。
	bool lengCompare(const string &,const string &);
	该函数的类型是bool(const string &,const string &)，要想声明一个指向该函数的指针，只需要用指针替换函数名：
	bool （*pf）(const string &,const string &);
	使用函数指针
	当我们把函数名作为一个值使用时，该函数自动的转换成指针：
	pf = lengthConpare;
	pf = &lengthConpare;//等价，取地址符是可选的
	此外，我们还能直接使用指向函数的指针调用该函数，无需提前解引用指针：
	bool b1 = pf(const string &,const string &);	//等价的三个调用
	bool b2 = (*pf)(const string &,const string &);
	bool b3 = lengthConpare(const string &,const string &);
	在指向不同函数类型的指针间不存在转换规则。但是和往常一样，我们可以为函数指针赋一个nullptr或者
	值为0的整型常量表达式，表示该指针没有指向任何一个函数。

	重载函数的指针
	当我们使用重载函数时，上下文必须清晰的界定到底该选用哪个函数。
	void ff(int*);
	void ff(unsigned int)l

	void (*pf1)(unsigned int) = ff;
	void (*pf2)(int) = ff;//错误
	double (*pf3)(int*) = ff;//错误

	函数指针形参
	和数组累死，虽然不能定义函数类型的形参，但是形参可以是指向函数的指针。

	返回指向函数的指针
	和数组类似，虽然不能返回一个函数，但是能返回指向函数类型的指针。
	然而，我们必须把返回类型写成指针形式，编译器不会自动的将函数返回类型当成对应的指针类型处理。
	要想声明一个返回函数指针的函数，最简单的办法是使用类型别名。
	using F = int (int*, int);//F是函数类型，不是指针
	using PF = int(*) (int*, int);//PF是指针类型
	和函数类型的形参不一样，返回类型不会自动的转换成指针，我们必须显示的将返回类型指定为指针：
	PF f1(int);//正确，PF是指向函数的指针，f1返回指向函数的指针
	F f1(int);//错误，F是函数类型，f1不能返回一个函数
	F *f1(int);//正确，显示的指定返回类型是指向函数的指针
	也能直接声明：
	int (f1(int))(int*,int);
	按照由内向外的顺序阅读这条声明语句：我们看到f1有形参列表，所以f1是个函数；
	f1前面有*，所以f1返回一个指针；进一步发现指针的类型本身也包含形参列表，因此指针指向函数，该函数的返回类型是int。
	也可以使用尾置返回类型的方式：
	auto f1(int) -> int (*)(int*,int);
*/