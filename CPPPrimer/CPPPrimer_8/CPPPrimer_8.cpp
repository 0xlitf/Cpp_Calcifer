// CPPPrimer_8.cpp : IO库
// CPPPrimer_8 IO库

#include "stdafx.h"
#include <iostream>
using namespace std;
int _tmain(int argc, _TCHAR* argv[])
{
	cout << "1 1" << ends;
	cin.get();





	return 0;
}



/*
8.1 IO类
	iostream,fstream,sstream

	8.11 IO对象无拷贝或赋值
	不能拷贝或对IO对象赋值，由于不能拷贝IO对象，因此我们也不能将形参或返回类型设置为流类型。
	进行IO操作的函数通常以引用方式传递和返回流。读写一个IO对象会改变其状态，因此传递和返回的引用不能是const的。

	8.12 条件状态
	确定一个流对象的章台的最简单的方法是将它最为一个条件来使用：
	while (cin >> word)
		//ok:读操作成功
	查询流的状态
	...
	管理条件状态
	...
	8.13 管理输入缓冲
	每个输入流都管理一个缓冲区，用来保存程序读写的数据。
	有了缓冲机制，操作系统就可以将程序的多个输出操作组合成单一的系统级别操作。
	由于设备的写操作可能很耗时，允许操作系统将多个输出操作组合为单一的设备写操作可以带来很大的性能提升。
	导致缓冲刷新（即，数据真正写到输出设备或文件）的原因有很多：
		程序正常结束，作为main函数的return操作的一部分，缓冲刷新被执行。
		缓冲区满时，需要刷新缓冲，而后新的数据才能继续写入缓冲区。
		使用endl操纵符来显式刷新缓冲区。
		在每个输出操作之后，可以使用操纵符unitbuf设置流的内部状态，来清空缓冲区。
		默认情况下，对cerr是设置unitbuf的，因此写到cerr的内容都是立即刷新的。
		一个输出流可能被关联到另一个流。在这种情况下，当读写被关联的流时，关联到流的缓冲区会被刷新。
		例如，默认情况下，cin和cerr都关联到cout。
		因此，读cin或写cerr都会导致cout的缓冲区被刷新。

	刷新输出缓冲区
		endl完成换行并刷新缓冲区的工作，IO库中还有两个类似的操纵符：flush和ends。
		flush刷新缓冲区，但不输出任何额外的字符；
		ends向缓冲区中插入一个空字符，然后刷新缓冲区。

		unitbuf操纵符
			如果想每次输出操作后都刷新缓冲区，可以使用unitbuf操纵符。
			它告诉流在接下来的每次写操作之后都进行一次flush操作。
			而nounitbuf操纵符则重置流，使其恢复使用正常的系统管理的缓冲区刷新机制：
			cout << unitbuf;		//所有输出操作后都会立即刷新缓冲区
			cout << nounitbuf;		//回到正常的缓冲方式
		如果程序崩溃，输出缓冲区不会被刷新。
	关联输入和输出流
		当一个输入流被关联到一个输出流时，任何试图从输入流读取数据的操作都会先刷新关联的输出流。
		标准库将cout和cin关联在一起，因此下面语句
		cin	>> ival;
		导致cout的缓冲区被刷新。

		tie有两个重载的版本：一个版本不带参数，返回指向输出流的指针。
		如果本对象当前关联到一个输出流，则返回的就是指向这个流的指针，如果对象未关联到流，则返回空指针。
		tie的第二个版本接受一个指向ostream的指针，将自己关联到此ostream。即x.tie(&o)将流x关联到输出流o。

		我们既可以将一个istream对象关联到另一个ostream，也可以将一个ostream关联到另一个ostream：
		...


8.2 文件输入输出
	头文件fstream定义了三个类型来支持文件IO:ifstream从一个给定文件读取数据，
	ofstream向一个给定文件写入数据，以及fstream可以读写给定文件。
	17.5.3节中介绍如何对同一个文件流即读又写。

	这些类型提供的操作与我们之前已经使用过的对象cin和cout的操作一样。
	特别是，我们可以用IO运算符（<<和>>）来读写文件，可以用getline从一个ifstream读取数据。

	除了继承自iostream类型的行为之外，fstream中定义的类型还增加了一些新的成员来管理与流关联的文件。

	8.21 使用文件流对象
		当想要读写一个文件时，可以定义一个文件流对象，并将对象与文件关联起来。
		每个文件流类都定义了一个名为open的成员函数，它完成一些系统相关的操作，来定为给定的文件，
		并视情况打开为读或写模式。

		用fstream代替iostream&
			在要求使用基类型对象的地方可以用继承类型的对象来替代。
			这意味着接受一个iostream类型引用（或指针）参数的函数，可以用一个对应的fstream（或sstream）类型来调用。
			也就是说，如果有一个函数接受一个ostream&参数，我们可以在调用这个函数时可以传递给它一个ofstream对象，
			对istream&和ifstream也是类似的。

		成员函数open和close
			如果定义了一个空文件流对象，可以随后调用open来将它与文件关联起来：

	8.22 文件模式
		每个流都有一个关联的文件模式（file mode），用来指出如何使用文件。

		文件模式
		in	以读方式打开
		out	以写方式打开
		app	每次写操作前均定位到文件末尾
		ate	打开文件后立即定为到文件末尾
		trunc	截断文件
		binary	以二进制方式进行IO
		无论用哪种方式打开文件，我们都可以指定文件模式，调用open打开文件时可以，
		用一个文件名初始化流来隐式打开文件时也可以。
		指定文件模式有如下限制：
		只可以对ofstream或fstream对象设定out模式。
		只可以对ifstream或fstream对象设定in模式。
		只有当out也被设定时才可设定trunc模式。
		只要trunc没被设定，就可以设定app模式。在app模式下，即使没有显式指定out模式，文件也总是以输出方式被打开。
		默认情况下，即使我们没有指定trunc，以out模式打开的文件也会被阶段。为了保留以out模式打开的文件的内容，
			我们必须同时指定app模式，这样只会将数据追加写到文件末尾；或者同时指定in模式，即打开文件同时进行读写操作。
		ate和binary模式可用于任何类型的文件流对象，且可以与其他任何文件模式组合使用。

		每个文件流类型都定义了一个默认的文件模式。，当我们未指定文件模式时，就使用此默认模式。
		与ifstream关联的文件默认以in模式打开；与ofstream关联的文件默认以out模式打开；
		与fstream关联的文件默认以in和out模式打开。

		以out模式打开文件会丢弃已有数据
			默认情况下，当我们打开一个ofstream时，文件的内容会被丢弃。阻止一个ofstream清空给定文件内容的方法是
			同时指定app模式：
			...

		每次调用open时都会确定文件模式
			对于一个给定流，每当打开文件时，都可以改变其文件模式

8.3 string流
	sstream头文件定义了三个类型来支持内存IO，这些类型可以向string写入数据，从string读取数据，就想string是一个IO流一样。
	istringstream从string读取数据，ostringstream向string写入数据，而头文件stringstream既可从string读数据也可向string
	写数据。
	与fstring类型类似，头文件sstream中定义的类型都继承自我们已经使用过的iostream头文件中定义的类型。

	stringstream特有的操作
	...

		8.31 使用istringstream

		8.32 使用ostringstream

*/