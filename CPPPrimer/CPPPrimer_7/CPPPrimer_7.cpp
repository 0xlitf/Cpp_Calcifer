// CPPPrimer_7.cpp : 类
// CPPPrimer_7 类

#include "stdafx.h"
#include "testclass.h"
#include <iostream>
int _tmain(int argc, _TCHAR* argv[])
{
	const testclass a;
	a.testFunc1();
//	a.testFunc2();
	int *p = new int;

	std::cin.get();
	return 0;
}

/*

	类的基本思想是数据抽象（data abstraction）和封装（encapsulation）。
	数据抽象是一种依赖于接口（interface）和实现（implementation）分离的编程技术。
	类要想实现数据抽象和封装，需要首先定义一个抽象数据类型（abstract data type）。
	在抽象数据类型中，由类的设计者负责考虑类的实现过程。
7.1 定义抽象数据类型
	
	成员函数通过一个名为this的额外的隐式参数来访问调用它的那个对象，当我们调用一个成员函数时，用请求该函数的对象地址
	初始化this。例如：
	如果调用total.isbn()
	则编译器负责把total的地址传递给isbn的隐式形参this，可以等价的写成
	Sales_data::isbn(&total)
	其中调用isbn成员时传入了total的地址。
	this是一个常量指针，不允许修改this中保存的地址。

	引入const成员函数
	isbn函数的另一个关键之处是紧随参数列表之后的const关键字，这里const的作用是修改隐式this指针的类型。
	默认情况下，this的类型是指向类类型非常量版本的常量指针。
	P231页，看不懂。

	类作用域和成员函数
	类本身就是一个作用域，类的成员函数的定义嵌套在类的作用域之内。
	编译器分两步处理类：首先编译成员的声明，然后才轮到成员函数体（如果有的话）。因此，成员函数体可以随意使用类中的其他成员而无需在意这些成员出现的次序。

	在类的外部定义成员函数
	像其他函数一样，当我们在类的外部定义成员函数时，成员函数的定义必须与它的声明匹配。
	也就是说，返回类型、参数列表和函数名都得到与类内部的声明保持一致，
	如果成员被声明成常量成员函数，那么他的定义也必须在参数列表后明确指定const属性。
	同时，类外部定义的成员的名字必须包含它所属的类名。
	
	定义一个返回this对象的函数
	Saled_data& Sales_data::conbine(const Sales_data &rhs)
	{
		...
		return *this；
	}
	解引用this指针以获得执行该函数的对象，换句话说，上面这个调用返回total的引用。

	7.13 定义类相关的非成员函数
	类的作者常常需要定义一些辅助函数，比如add、read、print等，尽管这些函数定义的操作从概念上来说属于类的接口的组成部分，但他们实际上并不属于类。
	istream &read(istream &is,Sales_data &item)
	{
		double price = 0;
		is >> item.bookNo >> item.units_sold >> price;

		return is;
	}

	7.14 构造函数
	每个类都分别定义了她的对象被初始化的方式，类通过一个或几个特殊的成员函数来控制其对象的初始化过程，
	这些函数叫做构造函数（constructor）。
	构造函数的任务是初始化类对象的数据成员，无论何时只要类的对象被创建，就会执行构造函数。
	构造函数的名字和类名相同。和其他函数不一样的是，构造函数没有返回类型；除此之外类似于其他函数。
	，构造函数也有一个（可能为空的）参数列表和一个（可能为空的）函数体。
	类可以包含多个构造函数，和其他重载函数差不多，不同的构造函数之间必须在参数数量或参数类型上有所区别。

	类通过一个特殊的构造函数来控制默认初始化过程，这个函数叫做默认构造函数（default constructor）。
	默认构造函数无需任何实参。
	如我们所见，默认构造函数再很多方面都有其特殊性，其中之一是，如果类没有显式的定义构造函数，编译器就会隐式的定义一个默认构造函数。
	编译器创建的构造函数又被称为合成的默认构造函数（synthesized default constructor）。
	对于大多数类来说，这个合成的默认构造函数将按照如下规则初始化类的数据成员：
	1、如果存在类内的初始值，用它来初始化成员。
	2、否则，默认初始化该成员。

	某些类不能依赖于合成的默认构造函数
	合成的默认构造函数只适合非常简单的类，对于一个普通的类来说，必须定义它自己的默认构造函数，原因有三：
	第一个原因就是编译器只有在发现类不包含任何构造函数的情况下才会替我们生成一个默认的构造函数。一旦我们定义了一些其他的构造函数，
	那么除非我们再定义一个默认的构造函数，否则类将没有默认构造函数。
	这条规则的一句是，如果一个类在某种情况下需要控制对象初始化，那么该类很可能在所有情况下都需要控制。
	第二个原因是对于某些类来说，合成的默认构造函数可能执行错误的操作。
	回忆我们之前介绍过的，如果定义在块中的内置类型或复合类型（比如数组和指针）的对象被默认初始化，则他们的值将是未定义的。
	该准则同样适用于默认初始化的内置类型成员。
	因此，含有内置类型或复合类型成员的类应该在类的内部初始化这些成员，或者定义一个自己的默认构造函数，否则，用户在创建类的对象时就可能得到未定义的值。
	第三个原因是有的时候编译器不能为某些类合成默认的构造函数。例如，如果类中包含了一个其他类类型的成员，且这个成员的类型没有默认构造函数，那么编译器无法初始化该成员。
	对于这样的类来说，我们必须自定义默认构造函数，否则该类将没有可用的默认构造函数。

	= default的含义
	Sales_data() = default;
	因为该构造函数不接受任何实参，所以它是一个默认构造函数。我们定义这个构造函数的目的仅仅是因为我们既需要其他形式的构造函数，也需要默认的构造函数。
	我们希望这个函数的作用完全等同于之前使用的合成默认构造函数。

	构造函数初始值列表
	Sales_data(const std::string &s):bookNo(s) {};
	冒号和花括号之间的部分成为构造函数初始值列表（constructor initialize list），
	它负责为新创建的一个或几个数据成员赋初值。
	构造函数的初始值是成员名字的一个列表。

	7.15 拷贝、赋值和西沟
	除了定义类的对象如何初始化之外，类还需要控制拷贝、赋值和销毁对象时发生的行为。
	对象在几种情况下会被拷贝，如初始化变量以及以值的方式传递或返回一个对象。
	当我们使用赋值运算符时会发生对象的赋值操作，当对象不再存在时执行销毁的操作，比如一个局部对象会在创建它的块结束时被销毁。
	当vector对象被销毁时，存储在其中的对象也会被销毁。





7.2 访问控制与封装
	C++中用访问说明符（access specifiers）加强类的封装性：
	定义在public说明符之后的成员在整个程序内可被访问，public成员定义类的接口。
	定义在private说明符之后的成员可以被类的成员函数访问，但是不能被使用该类的代码访问，private部分封装了（隐藏了）类的实现细节。

	class和struct的区别
	如果使用struct，则定义在第一个访问说明符之前的成员是public；
	相反如果使用class ，则是private。


	7.21 友元
	类可以允许其他类或者函数访问它的非公有成员，方法是令其他类或者函数成为他的友元（friend）。
	class Sales_data{
	friend std::istream &read(std::istream&,Sales_data&);
	...
	}
	友元声明只能出现在类定义的内部，但是在类内出现的具体位置不限。友元不是类的成员，也不受它所在区域访问控制界别的约束。







7.3 类的其他特性
	7.31 类成员再探
	除了定义数据和函数成员之外，类还可以自定义某种类型在类中的别名。
	由类定义的类型名字和其他成员一样存在访问限制，可以是public或者private中的一种：
	class Screen{
	public:
		typedef std::string::size_type pos;
		using pos = std::string::size_type;//第二种方法
	private:
		pos cursor = 0;
		pos height = 0,width = 0;
		std::string contents;
	};
	用来定义类型的成员必须先定义后使用。所以，类型成员通常出现在类开始的地方。


	重载成员函数
	和非成员函数一样，成员函数也可以被重载，只要函数之间在参数的数量和/或类型上有所区别就行。
	成员函数的函数匹配过程同样和非成员函数非常类似。

	类内初始值必须使用=的初始化形式，或者花括号括起来的直接初始化形式。

	7.33 类类型
	每个类定义了唯一的类型。对于两个类来说，即使他们的成员完全一样，这两个类也是两个不同的类型。
	即使两个类的成员列表完全一致，它们也是不同的类型。
	可以把类名作为类型的名字使用，从而直接指向类类型。或者也可以把类名跟在关键字class或struct后：
	A a;
	class A a;

	类的声明
	就像可以把函数的声明和定义分离开来一样，我们也能仅仅声明类而暂时不定义它：
	class A;//类的声明
	这种声明有时被称作前向声明（forward declaration），它向程序中引入了名字A并且指明A是一种类类型，
	对于类型A来说，在它声明之后定义之前是一个不完全类型（incomplete type），也就是说，此时我们已知A是一个类类型，但是不清楚它到底包含哪些成员。
	不完全类型智能在非常有限的情景下使用：可以定义指向这种类型的引用或指针，
	也可以声明（但是不能定义）以不完全类型作为参数或者返回类型的函数。

	例外情况：
	直到类被定义之后数据成员才能被声明成这种类类型。
	换句话说，我们必须首先完成类的定义，然后编译器才能知道存储该数据成员需要多少空间。
	因为只有当类全部完成后类才算被定义，所以一个类的成员类型不能是该类自己。
	然而，一旦一个类的名字出现后，它就被认为是声明过了（但尚未定义），因此类允许包含指向它自身类型的引用或指针。

	7.34 友元再探
	类可以把其他类定义成友元，也可以把其他类的成员函数定义成友元。
	此外，友元函数能定义在类的内部，这样的函数是隐式内联的。
	class A{
	friend class B;//B可以访问A的私有部分
	friend class B::b();
	}
	如果一个类指定了友元类，则友元类的成员函数可以访问此类包括非公有成员在内的所有成员。

	函数重载和友元
	尽管重载函数的名字相同，但它们仍然是不同的函数。
	因此，如果一个类想把一组重载函数声明成它的友元，需要对这组函数中的每一个分别声明。

	友元声明和作用域
	友元声明的作用是影响访问权限，它本身并非普通意义上的声明。







7.4 类的作用域
	每个类都会定义他自己的作用域。
	在类的作用域之外，普通的数据和函数成员只能由对象、引用或者指针使用成员访问运算符来访问。
	对于类类型成员则使用作用域运算符来访问。
	不论哪种情况，跟在运算符之后的名字都必须是对应类的成员。
	
	7.41 名字查找与类的作用域
	类的定义分两步处理：
	首先，编译成员的声明。
	直到类全部可见后才编译函数体。












7.5 构造函数再探
	构造函数初始值列表
	当我们定义变量时习惯于立即对其进行初始化，而非先定义、再赋值：
	string foo = ="hello world";//定义并初始化
	string bar;			//初始化成空string对象
	bar = "hello world";//为bar赋一个新值

	就对象的数据成员而言，初始化和赋值也有类似区别。
	如果没有在构造函数的初始值列表中显式的初始化成员，则该成员将在构造函数体之前执行默认初始化。
	构造函数的初始值有时必不可少
	有时可以忽略数据成员初始化和赋值之间的差异，但并非总是这样，
	如果成员是const或者是引用的话，必须将其初始化。
	类似的，当成员属于某种类类型且该类没有定义默认构造函数时，也必须将这个成员初始化。
	class A{
	public:
		A(int ii);
	private:
		int i;
		const int ci;
		int &ri;
		};
	和其他常量对象或者引用一样，成员ci和ri都必须被初始化。
	因此，如果没有为他们提供构造函数初始值的话将引发错误。
	初始化const或者引用类型的数据成员的唯一机会就是通过构造函数初始值：
	A::A(int ii):i(ii),ci(ii),ri(i) {};
	
	成员初始化的顺序
	构造函数初始值列表只说明用于初始化成员的值，而不限定初始化的具体执行顺序。
	成员的初始化顺序与他们在类定义中的出现顺序一致：第一个成员先被初始化，然后第二个，以此类推。
	构造函数初始值列表中初始值的前后位置关系不会影响实际的初始化顺序。
	class X{
		int i;
		int j;
		public:
		//未定义的：i在j之前被初始化
		X (int val): j(val),i(j){};
		};
	在此例中，从构造函数初始值的形式上来看仿佛是先用val初始化了j，然后再用j初始化i。
	实际上，i先被初始化，因此这个初始值的效果是试图使用未定义的值j初始化i。
	最好令构造函数初始值的顺序与成员声明的顺序保持一致。而且如果可能的话，尽量避免使用某些成员初始化其他成员。

	默认实参和构造函数
	如果一个构造函数为所有参数都提供了默认实参，则它实际上也定义了默认构造函数。

	7.52 委托构造函数
	C++11新标准扩展了构造函数初始值的功能，使得我们可以定义所为的委托构造函数（delegating constructor）。
	一个委托构造函数使用它所属类的其他构造函数执行它自己的初始化过程，或者说它把它自己的一些（或者全部）职责委托给其他构造函数。

	7.53 默认构造函数的作用
	当对象被默认初始化或值初始化时自动执行默认构造函数。
	默认初始化在一下情况发生：
	1、当我们在块作用域内不使用任何初始值定义一个非静态变量或者数组时。
	2、当一个类本身含有类类型的成员且使用合成的默认构造函数时。
	3、当类类型的成员没有在构造函数初始值列表中显式的初始化时。
	4、在数组初始化的过程中如果我们提供的初始值数量少于数组的大小时。
	5、当我们不适用初始值定义一个局部静态变量时。
	6、当我们通过书写形如T()的表达式显式的请求值初始化时，其中T是类型名。
	类必须包含一个默认构造函数以便在上述情况下使用。

	7.54 隐式的类类型转换
	转换构造函数，将一种类类型转换为另一种类类型。
	能通过一个实参调用的构造函数定义了一条从构造函数的参数类型向类类型隐式转换的规则。
	
	只允许一步类类型转换

	类类型转换不是总有效

	抑制构造函数定义的隐式转换
	在要求隐式转换的程序上下文中，我们可以通过将构造函数声明为explicit。
	关键字explicit只对一个实参的构造函数有效。需要多个实参的构造函数不能用于执行隐式转换，所以无需指定成explicit。
	只能在类内声明构造函数时使用explicit，在类外部定义时不应重复。

	为转换显式的使用构造函数
	
	标准库中含有显示构造函数的类
	1、接受一个但参数的const char*的string构造函数不是explicit的。
	2、接受一个容量参数的vector构造函数是explicit的。

	7.55 聚合类
	聚合类（aggregate class）使得用户可以直接访问其成员，并且具有特殊的初始化语法形式。
	当一个类满足如下条件时，我们说它是聚合的：
	1、所有成员都是public的。
	2、没有定义任何构造函数。
	3、没有类内初始值。
	4、没有基类，也没有virtual函数。

	7.56 字面值常量类
	constexpr构造函数
	尽管构造函数不能是const的，但是字面值常量类的构造函数可以是constexpr函数。
	事实上，一个字面值常量类必须至少提供一个constexpr函数。







7.6 类的静态成员
	声明静态成员
	我们通过在成员的声明之前加上关键字static使得其与类关联在一起。
	和其他成员一样，静态成员可以是public的或private的。
	静态数据成员的类型可以是常量、引用、指针、类类型等。
	类的静态成员存在于任何对象之外，对象中不包含任何与静态数据成员有关的数据。
	类似的，静态成员函数也不与任何对象绑定在一起，它们不包含this指针。
	作为结果，静态成员函数不能声明成const的，而且也不能在static函数体内使用this指针。

	使用类的静态成员
	虽然静态成员不属于类的某个对象，但是仍然可以使用类的对象、引用或者指针来访问静态成员。

	定义静态成员
	和其他的成员函数一样，既可以在类的内部也可以在类的外部定义静态成员函数。
	当在类的外部定义静态成员时，不能重复static关键字，该关键字值出现在类内部的声明语句。
	因为静态数据成员不属于类的任何一个对象，所以它们并不是在创建类的对象时被定义的。
	这意味着它们不是由类的构造函数初始化的。
	而且一般来说，我们不能在类的内部初始化静态成员。
	相反的，必须在类的外部定义和初始化每个静态成员。
	和其他对象一样，一个静态数据成员只能定义一次。
	类似于全局变量，静态数据成员定义在任何函数之外。因此一旦它被定义，九江一直存在于程序的整个生命周期。

	静态成员的类内初始化
	看不懂。

	静态成员能用于某些场景，而普通成员不能




	C++ 类中特殊的成员变量（常变量、引用、静态）的初始化方法

	有些成员变量的数据类型比较特别，它们的初始化方式也和普通数据类型的成员变量有所不同。这些特殊的类型的成员变量包括：

	a.引用

	b.常量

	c.静态

	d.静态常量(整型)

	e.静态常量(非整型)

	常量和引用，必须通过参数列表进行初始化。
	静态成员变量的初始化也颇有点特别，是在类外初始化且不能再带有static关键字，其本质见文末。

	参考下面的代码以及其中注释：
	#include <iostream>
	using namespace std;

	class BClass
	{
	public:
	BClass() : i(1), ci(2), ri(i){} // 对于常量型成员变量和引用型成员变量，必须通过参数化列表的方式进行初始化
	//普通成员变量也可以放在函数体里，但是本质其实已不是初始化，而是一种普通的运算操作-->赋值运算，效率也低
	private:
	int i;                                  // 普通成员变量
	const int ci;                           // 常量成员变量
	int &ri;                                // 引用成员变量
	static int si;                          // 静态成员变量
	//static int si2 = 100;                 // error: 只有静态常量成员变量，才可以这样初始化
	static const int csi;                   // 静态常量成员变量
	static const int csi2 = 100;            // 静态常量成员变量的初始化(Integral type)    (1)
	static const double csd;                // 静态常量成员变量(non-Integral type)
	//static const double csd2 = 99.9;      // error: 只有静态常量整型数据成员才可以在类中初始化
	};

	//注意下面三行：不能再带有static
	int BClass::si = 0; // 静态成员变量的初始化(Integral type)
	const int BClass::csi = 1; // 静态常量成员变量的初始化(Integral type)
	const double BClass::csd = 99.9; // 静态常量成员变量的初始化(non-Integral type)

	// 在初始化(1)中的csi2时，根据著名大师Stanley B.Lippman的说法下面这行是必须的。
	// 但在VC2003中如果有下面一行将会产生错误，而在VC2005中，下面这行则可有可无，这个和编译器有关。
	const int BClass::csi2;

	int main()
	{
	BClass b;
	return 0;
	}



	---------------------------------------------------------------------------------------------

	静态成员属于类作用域，但不属于类对象，和普通的static变量一样，程序一运行就分配内存并初始化，生命周期和程序一致。
	所以，在类的构造函数里初始化static变量显然是不合理的。
	静态成员其实和全局变量地位是一样的，只不过编译器把它的使用限制在类作用域内（不是类对象，它不属于类对象成员），要在类的定义外（不是类作用域外）初始化。


*/