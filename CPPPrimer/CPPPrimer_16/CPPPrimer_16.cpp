// CPPPrimer_16.cpp : 模板与泛型编程
//

#include "stdafx.h"
//#include <windows.h>
#include <iostream>
#include "A.h"
using namespace std;
enum MyEnum
{
	
	a = 1
};
class A;

extern int b;

int _tmain(int argc, _TCHAR* argv[])
{
	int *p = new int;
	delete p;
	cout << b;
//	Sleep(2000);
	system("pause");
	return 0;
}

/*
CPPPrimer_16 模板与泛型编程
	模板是C++泛型编程的基础。一个模板就是一个创建类或函数的蓝图或者公式。
	当使用一个vector这样的泛型编程，或者find这样的泛型函数时，我们提供足够的信息，将蓝图转换为特定的类或函数。
	这种转换发生在编译时。
16.1 定义模板
	16.1.1 函数模板
		我们可以定义一个通用的函数模板（function template），而不是为每个类型都定义一个新函数。
		一个模板就是一个公式，可用来生成针对特定类型的函数版本。
		template <typename T>
		int compare(const T &v1,const T &v2)
		{
			if(v1<v2) return -1;
			if(v1>v2) return 1;
			return 0;
		}
		模板定义以关键字template开始，后跟一个模板参数列表（tamplate parameter list），
		这是一个逗号分隔的一个或多个模板参数（tamplate parameter）的列表。
		用于小于号（<）和大于号（>）包围起来。
		在模板定义中，模板参数列表不能为空。

		模板参数列表的作用很像函数参数列表。
		函数参数列表定义了若干特定类型的局部变量，但并未指出如何初始化他们。在运行时，调用者提供实参来初始化形参。
		类似的，模板参数表示在类或函数定义中用到的类型或值。
		当使用模板是，我们（隐式的或显示的）指定模板实参（template argument），将其绑定到模板参数上。

		我们的compare函数声明了一个名为T的类型参数。
		在compare中，我们用名字T表示一个类型。
		而T表示的实际类型则在编译时根据compare的使用情况来确定。

		实例化函数模板
			当我们调用一个函数模板时，编译器（通常）用函数实参来为我们推断模板实参。

			编译器用推断出的模板参数来为我们实例化（instantiate）一个特定版本的函数。
			当编译器实例化一个模板时，它使用时机的模板实参代替对应的模板参数来创建出模板的一个新“实例”。

		模板类型参数
			我们的compare函数有一个模板类型参数（type parameter）。
			一般来说，我们可以将类型参数看做类型说明符，就像内置类型或类类型说明符一样试用。
			特别是，类型参数可以用来指定返回类型或函数的参数类型，以及在函数体内用于变量声明或者类型转换。

			类型参数前必须使用关键字class或typename：
			//错误：U之前必须加上class或typename
			template <typename T,U> T calc(const T&,const U&);
			在模板参数列表中，这两个关键字的含义相同，可以互换使用。
			一个模板参数列表中可以同时使用这两个关键字：
			//正确：在模板参数列表中，typename和class没有什么不同
			template <typename T,class U> calc(const T&,const U&);

		非类型模板参数
			出了定义类型参数，还可以在模板中定义非类型参数（nontype parameter）。
			一个非类型参数表示一个值而非一个类型。
			我们通过一个特定的类型名而非关键字class或typename来指定非类型参数。

			当一个模板被实例化时，非类型参数被一个用户提供的或编译器推断出的值所代替。
			这些值必须是常量表达式，从而允许编译器在编译时实例化模板。

			一个非类型参数可以是一个整形，或者是一个指向对象或函数类型的指针或（左值）引用。
			绑定到非类型整型参数的实参必须是一个常量表达式。绑定到指针或引用非类型参数的实参必须具有静态的生存期。
			我们不能用一个普通（非static）局部变量或动态对象作为指针或引用非类型模板参数的实参。
			指针参数也可以用nullptr或一个值为0的常量表达式来实例化。

			在模板定义内，模板非类型参数是一个常量值。在需要常量表达式的地方可以使用非类型参数，例如，指定数组大小。

		inline和constexpr的函数模板
			函数模板呢可以声明为inline或constexpr的，如同非模板函数一样。
			inline或constexpr说明符放在模板参数列表之后，返回类型之前：
			//正确：inline说明符跟在模板参数列表之后
			template <typename T> inline T min(const T&,const T&);
			//错误：inline说明符的位置不正确
			inline template <typename T> T min(const T&,const T&);
		编写类型无关的代码
			我们最初的conpare函数虽然简单，但它说明了编写泛型代码的两个重要原则：
			>模板中的函数参数是const的引用。
			>函数体中的条件判断进使用<比较运算。
		模板程序应该尽量减少对实参类型的要求。
			
		模板编译
			当编译器遇到一个模板定义时，它并不生成代码。只有当我们实例化出模板的一个特定版本时，编译器才会生成代码。
			当我们使用（而不是定义）模板时，编译器才生成代码，这一特性影响了我们如何组织代码以及错误何时被检测到。

			通常，当我们调用一个函数时，编译器只需要掌握函数的声明。
			类似的，当我们使用一个类类型的对象时，类定义必须是可用的，但成员函数的定义不必已经出现。
			因此，我们将类定义和函数声明放在头文件中，而普通函数和类的成员函数的定义放在源文件中。
			模板则不同：为了生成一个实例化版本，编译器需要掌握函数模板或类模板成员函数的定义。
			因此，与非模板代码不同，模板的头文件通常既包括声明也包括定义。

			函数模板和类模板成员函数的定义通常放在头文件中。

		关键概念：模板和头文件
			模板包含两种名字：
			>那些不依赖于模板参数的名字
			>那些依赖于模板参数的名字
			当使用模板时，所有不依赖于模板参数的名字都必须是可见的，这是由模板的提供者来保证的。
			而且，模板的提供者必须保证，当模板被实例化时，模板的定义，包括类模板的成员的定义，也必须是可见的。

			用来实例化模板的所有函数、类型以及与类型关联的运算符的声明都必须是课件的，这是由模板的用户来保证的。

			通过组织良好的程序接口，恰当使用头文件，这些要求都很容易满足。
			模板的设计者应该提供一个头文件，包含模板定义以及在类模板或成员定义中用到的所有名字的声明。
			模板的用户必须包含模板的头文件，以及用来实例化模板的任何类型的头文件。


		大多数编译错误在实例化期间报告
			...

	16.1.2 类模板
		类模板（class template）是用来生成类的蓝图的。与函数模板的不同之处是，编译器不能为类模板推断模板参数类型。
		如我们已经多次看到的，为了使用类模板，我们必须在模板名后的尖括号中提供额外信息――用来代替模板参数的模板实参列表。

		类似函数模板，类模板以关键字template开始，后跟模板参数列表。
		在类模板（机器成员）的定义中，我们将模板参数当做提神，代替使用模板时用户需要提供的类型或值：
		template <typename T> class Blob {
		public:
			typedef T value_type
			typedef typename std:vector<T>::size_type size_type;

			//构造函数
			Blob();
			Blob(std::initializer_list<T> il);
			//Blob中的元素数目
			size_type size() const {return data->size();}
			bool empty() const {return data->empty();}
		private:
			std::shared_ptr<std::vector<T>> data;
			};

		实例化类模板
			当使用一个类模板时，我们必须提供额外信息。
			这些额外信息是显式模板实参（explicit template argument）列表，它们被绑定到模板参数。
			编译器使用这些模板实参来实例化出特定的类。
			例如：
			Blob<int> ia;					//空Blob<int>
			Blob<int> ia2 = {1,2,3,4,5};	//有5个元素的Blob<int>

			当编译器从模板实例化一个类是，它会重写Blob模板，将模板参数T的每个实例替换为给定的模板实参，在本里中是int。

			一个类模板的每个实例都形成一个独立的类。

			在模板作用域中引用模板类型
				为了阅读模板类代码，应该记住类模板的名字不是一个类型名。
				类模板用来实例化类型，而一个实例化的类型总是包含模板参数的。

				类模板的成员函数
					与其他任何类相同，我们既可以在类模板内部，也可以在类模板外部为其定义成员函数，
					且定义在类模板内的成员函数被隐式声明为内联函数。
					
					类模板的成员函数本身是一个普通函数。
					但是，类模板的每个实例都有其自己版本的成员函数。
					因此，类模板的成员函数具有和模板相同的模板参数。
					因为，定义在内模板之外的成员函数就必须以关键字template开始，后接类模板参数列表。

	16.1.3 模板参数
		类似函数参数的名字，一个模板参数的名字也没有什么内在含义。
		我们通常将类型参数命名为T，但实际上可以使用任何名字：
		template <typename Foo> Foo calc(const Foo& a,const Foo& b)
		{
			Foo tmp = a;

			return tmp;
		}
		模板参数与作用域
			模板参数遵循普通的作用域规则。一个模板参数名的可用范围是在其声明之后，至模板声明或定义结束之前。
			与任何其他名字一样，模板参数会隐藏外层作用域中声明的相同名字。
			但是，与大多数其他上下文不同，在模板内不能重用模板参数名：

			typedef double A;
			template <typename A,typename B> void f(A a,B b)
			{
				A tmp = a;//tmp的类型为模板参数A的类型，而非double
				double B;//错误：重声明模板参数B
			}
			正常的名字隐藏规则决定了A的typedef被类型参数A隐藏。
			因此，tmp不是一个double，其类型是使用f时绑定到类型参数A的类型。
			由于我们不能重用模板参数名，声明名字为B的变量是错误的。
			由于参数名不能重用，所以一个模板参数名在一个特定模板参数列表中只能出现一次：
			错误：非法重用模板参数名
			template <typename V,typename V> //...

			模板声明
				模板声明必须包含模板参数：
				//声明但不定义compare
				template <typename T> int compare(const T&,const T&);
				与函数参数相同，声明中的模板参数的名字不必与定义中相同：
				//3个calc都指向相同的函数模板
				template <typename T> int compare(const T&,const T&);
				template <typename U> int compare(const U&,const U&);
				template <typename T> 
				int compare(const T& a,const T& b);
			使用类的类型成员
				我们用作用域运算符（::）来访问static成员和类型成员。
				在普通（非模板）代码中，编译器掌握类的定义。
				因此，它知道通过作用域运算符访问的名字是类型还是static成员。
				例如，如果我们写下string::size_type，编译器有string的定义，从而知道size_type是一个类型。
				但对于模板代码就存在困难。例如，假定T是一个模板类型参数，当编译器遇到类似T::mem这样的代码时，它不会知道mem是一个类型成员还是一个static数据成员，
				直至实例化时才会知道。
				但是，为了处理模板，编译器必须知道名字是否表示一个类型。
				例如，假定T是一个类型参数的名字，当编译器遇到如下形式的语句时：
				T::size_type * p；它需要知道我们是正在定义一个名为p的变量还是将一个名为size_type的static数据成员与名为p的变量相乘。
				默认情况下，C++语言假定通过作用域符访问的名字不是类型。因此，如果我们希望使用一个模板类型参数的类型成员，就必须显式告诉编译器该名字是一个类型。
				使用关键字typename来实现这一点：
				template <typename T>
				typename T::value_type top(const T& c)
				{
					return typename T::value_type();
				}
				当我们希望通知编译器一个名字表示类型时，必须使用关键字typename，而不能使用class。

				默认模板实参
					就像我们能为函数提供默认实参一样，我们也可以提供默认模板实参（default template argument）。
					新标准中，我们可以为函数和类模板提供默认实参。
				模板默认实参与类模板
					无论何时使用一个类模板，我们都必须在模板命之后接上尖括号。尖括号指出类必须从一个模板实例化而来。
					特别是，如果一个类模板为其所有模板参数都提供了默认实参，且我们希望使用这些默认实参，就必须在模板名之后跟一个空尖括号对：
				template <class T = int> class Numbers{ //T默认为int
				public:
					Numbers(T v = 0): val(v){}
				private:
					T val;
				};
				Numbers<long double> lots_of_precision;
				Numbers<> average_precision;//空<>表示我们希望使用默认类型

	16.1.4 成员模板
		普通（非模板）类的成员模板
			作为普通类包含成员模板的例子，我们定义一个类，类似unique_ptr所使用的默认删除器类型。
			类似默认删除器，我们的类将包含一个重载的函数调用运算符，它接受一个指针并对此指针执行delete。
		类模板的成员模板
			对于类模板，我们也可以为其定义成员模板。在此情况下，类和成员各自有自己的独立的模板参数。
			template <typename T> class Blob{
			template <typename It> Blob(It b,It e);
			//...
			}
		实例化与成员模板
			为了实例化一个类模板的成员模板，我们必须同时提供类和函数模板的实参。
			与往常一样，我们在哪个对象上调用成员模板，编译器就根据该对象的类型来推断类模板参数的实参。
			与普通函数模板相同，编译器通常根据传递给成员模板的函数实参来推断它的模板实参：
			int ia[] = {0,1};
			vector<long> vi = {0,1};
	16.1.5 控制实例化
		当模板使用时才会进行实例化这一特性意味着，相同的实例可能出现在多个对象文件中。
		当两个或多个独立编译的源文件使用了相同的模板，并提供了相同的模板参数时，每个文件中都会有该模板的一个实例。
		在大系统中，在多个文件中实例化相同模板的额外开销可能非常严重。
		在新标准中，我们可以通过显式实例化{explicit instantiation）来避免这种开销。
		一个显式实例化有如下形式：
		extern template declaration;//实例化声明
		template declaration;//实例化定义
		对每个实例化声明，在程序中某个位置必须有其显式的实例化定义。

		实例化定义会实例化所有成员
			一个类模板的实例化定义会实例化该模板的所有成员，包括内联的成员函数。
			在一个类模板的实例化定义中，所用类型必须能用于模板的所有成员函数。

	16.1.6 效率与灵活性
		
16.2 模板实参推断
	16.2.1 类型转换与模板类型参数

	16.2.2 函数模板显式实参

	16.2.3 尾置返回类型与类型转换

	16.2.4 函数指针和实参推断

	16.2.5 模板实参推断和引用

	16.2.6 理解std::move

	16.2.7 转发

16.3 重载与模板
	
16.4 可变参数模板

	16.4.1 编写可变参数函数模板

	16.4.2 包扩展

	16.4.3 转发参数包

16.5 模板特例化
	






*/